<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
    function Fn(name,age){
        this.name=name;
        this.age=age;
    }
    Fn.prototype.say=function(){
        console.log(this)
    };
    Object.prototype.w=1;
    let f1=new Fn('hhh',18);
    let f2=new Fn('nnn',19);
    console.log(Fn.prototype)//{say:f,constructor:f}
    console.log(f1)//hhh 18
    f1.say()
    Fn.prototype.say()//{say:f,constructor:f}
    console.log(f1.__proto__.__proto__.__proto__)//null
    console.log(f1.w)//1
    console.log(f1 instanceof Fn)//true
    //构造函数解决了实例的私有属性
    //原型模式解决了实例的公有属性
    //1、每一个函数天生自带一个prototype属性，其属性值是一个对象，这里对象存储的是公有属性，（这个对象也叫做原型）
    //2、每一个原型天生自带一个constructor属性，其属性值指向当前的类
    //3、每一个对象天生自带一个__proto__属性，其属性值指向所属类的原型
    //原型链：在对象里查找一个属性，先看自己私有的有没有，如果有就直接用，如果没有就通过__proto__找到当前所属类的原型，原型上有，就使用，如果原型上也没有，通过原型的__ptoto__找到原型所属类的原型，直到找到Object的原型为止，如果还没有，就是undefined，这种一级一级向上查找的机制就形成了原型链
    //用Instanceof检测数据类型，只要类的原型出现在被检测实例的原型链上，那就返回true
    Array.prototype.say = function(){
             console.log('哈哈')
         }
         let ary = [1,2,3,4,5];
         ary.say()
     
    </script>
</body>
</html>