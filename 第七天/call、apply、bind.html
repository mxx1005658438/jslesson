<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
    /*
    call 、apply、bind方法:他们是改变函数的this指向的
    他们是function原型上的方法
    而且每一个函数都是function的实例，他们的__proto__都指向function的原型，所以每一个函数都可以调用function原型上的方法，每一个函数都可以调用call、apply、bind
    */
        function fn(){
           console.log(this)
        }
         let obj = {name:1};
       fn();

          obj.fn = fn;
         obj.fn();
         delete obj.fn
        console.log(obj)
       /* 
        当前fn函数作为对象，找到当前所属类原型上的call方法，并且让call方法执行，
        在call方法执行的时候给他传递实参
        在call方法执行的时候，call内部执行了fn方法，并且让fn的this指向了call的第一个实参,然后call的实参从第二个开始就是fn执行时的实参
        */
        
        function fn(n, m) {
            console.log(this,n,m);
        }
        let obj = {
            name: 1
        };
        fn()
        fn.call(obj,1,2); // 执行fn，并且把fn的this指向改变
       /* 
        1、在严格模式下，如果call不传参或者传undefined，那fn的this是undefined，如果传null，那fn的this是null
        2、在非严格模式下，call不传参或者传undefined或者传null，那fn的this是window
        3、除了这几中情况，那fn里的this你传啥就是啥
        */
    </script>
</body>
</html>